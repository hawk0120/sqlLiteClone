Any application that can be written in JavaScript, will eventually be written in JavaScript.

-- Jeff Atwood, 2009


# Part 1 - Introduction & Setting up the REPL

As a Software developer, databases are foundational to the work that I do. I don't understand them. Similar to Artificial Intelligence, they feel like this magically place that you can interact with and it stores your data in a neat and reproducable way. I have these questions:

-> What format is data saved in? (In memory and on disk)\
-> When does it move from memory to disk?\
-> Why can there only be on primary key per table?\
-> How dows rolling back a transaction work?\
-> How are indexes formateted?\
-> When and how does a full table scan happen?\
-> What format is a prepared statement saved in?

Or to put it more bluntly, how does a database work?

I'm going to build a database from scratch. I'll model it on sqlite because its designed to be smaller with fewer features than MySQL or PostgreSQL.


## Sqlite

There's lots of document of sqlite internals on their website.

A query goes through a chain of components in order to retrive or modify data. The 'Front-end' consists of the:

-> tokenizer\
-> parser\
-> code generator

The input is an SQL query. The output is sqlite's virtual machine bytecode (essentially a compiled program that can operate on the database, more on this later).

The 'back-end' consists of the following:
-> virtual machine\
-> B-tree\
-> pager\
-> os interface

The virtual machine takes bytecode generated by the code generator as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a datastructure called a B-tree. The VM is essentially a big switch statement on the type of bytecode instruction.

Each B-tree consists of many nodes. Each node is one page in length. The B-tree can retrieve a page from disk or save it back to disk by issueing commands to the pager.

The pager receives commands to read/write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently accessed pages in memory, and determines when those pages need to be written back to disk.

The OS interface is the layer that differs depending on which operating system Sqlite was compiled for. In this tutorial, I won't support multiple platforms, I use Ubuntu 22.04, so that's what I'll support.


## Making a Simple REPL

Sqlite starts a read-execute-print loop when you start from the terminal. To do this, our main file will have an infinite loop that prints the prompt, gets a line of input, then processes that line of input. I'll write it in typescript because of 'Anything that can be written in javascript, will eventually be written in javascript'.  

```js
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

function main() {
  rl.question('sql>>> ', (input) => {
      if (input.trim() === '.exit') {
      rl.close();
      return;
      } else {
      console.log("Processing input:", input);
      }
      main();
      });
}

console.log("Welcome to Brady's sqlite clone!");

main();
```


Alright, we've got a working REPL. In the next part, we'll start developing our command language.



